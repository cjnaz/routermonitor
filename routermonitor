#!/usr/bin/env python3
"""Monitor for new devices/clients on the network.

The network dhcp server is queried for currently known DHCP clients.
Any new clients are identified and a notification is sent.  
See the README.md for setup requirements.
"""

__version__ = "V1.4 220915"


#==========================================================
#
#  Chris Nelson, 2020 - 2021
#
# 220915 V1.4   Added snd_notif exception catch
# 220217 V1.3   Updated for funcs3 V1.0
# 211114 V1.2   Added --print-log, set --list-db as default if no other operations, incorporated scrape_pfsense_dhcp and eliminated the module.
# 211108 V1.1   Increased MACOUI and notes column widths to 255 in the db.  Added optional MACOUI_field_width to the config file (default 30).
# 211107 V1.0   Added support for pfSense (now the default mode)
# 210523 V0.7   New device message tweaks, Requires funcs3 V0.7 min for import of credentials file and config reload.
#   Added --config-file and --log-file switches
# 210215 V0.6   Added --swizzle-db, --swizzle-commit, and reworked first_seen and expiry to Int storage.
# 210125 V0.5   Added --service mode
# 200715 v0.4   Added --sort-by
# 200530 v0.3   Added database record search
# 200527 v0.2.2 Bug fix for single line lookup_MAC response losing last letter.
# 200526 v0.2.1 Bug fix for finding not just first new device on an update run.
# 200522 v0.2   Track host name changes, support single quotes in notes, support older subprocess.checkoutput()
# 200426 v0.1   New
#
# Changes pending
#   
#==========================================================

import argparse
import subprocess
import sys
import re
import time
import datetime
import os.path
import collections
import mysql.connector
import requests
import signal
from lxml import html

sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), '../funcs3/'))    # funcs3 in peer dir
from funcs3 import PROGDIR, logging, loadconfig, getcfg, snd_notif, funcs3_min_version_check, funcs3_version

# Configs / Constants
FUNCS3_MIN_VERSION = 1.0
CONFIG_FILE = os.path.join(PROGDIR, 'routermonitor.cfg')
CONSOLE_LOGGING_FORMAT = '{levelname:>8}:  {message}'


py_version = float(sys.version_info.major) + float(sys.version_info.minor)/10


def main():

    # Check for database access and populate if non-existing
    db_connection = mysql.connector.connect(host=getcfg("DB_HOST"), user=getcfg("DB_USER"), passwd=getcfg("DB_PASS"))
    db_cursor = db_connection.cursor()
    db_cursor.execute("SHOW DATABASES")
    found = False
    for db in db_cursor:
        if getcfg("DB_DB") in db[0]:
            found = True
            break
    if not found:
        print(f"ERROR:  Manually create the <{getcfg('DB_DB')}> database.")
        sys.exit(1)

    db_connection = mysql.connector.connect(database=getcfg("DB_DB"), host=getcfg("DB_HOST"), user=getcfg("DB_USER"), passwd=getcfg("DB_PASS"))
    db_cursor = db_connection.cursor(buffered=True, dictionary=True)
    db_cursor.execute("SHOW TABLES")
    found = False
    for row in db_cursor:
        if getcfg('DB_TABLE') in row['Tables_in_' + getcfg('DB_DB')]:
            found = True
            break

    if found and args.create_db:
        db_cursor.execute(f"DROP TABLE {getcfg('DB_TABLE')}")
        db_connection.commit()

    db_fields = "MAC VARCHAR(17), hostname VARCHAR(25), notes VARCHAR(255), first_seen INT, expiry INT, IP VARCHAR(15), MACOUI VARCHAR(255)"
    def db_add_client(MAC, record):
        cmd = "INSERT INTO {} (MAC, MACOUI, hostname, notes, first_seen, IP, expiry) VALUES (\'{}\', \'{}\', \'{}\', \'{}\', {}, \'{}\', {})".format(
            getcfg('DB_TABLE'),
            MAC,
            lookup_MAC(MAC),
            record['hostname'],
            "-",
            time.time(),
            record['IP'],
            record['expiry'])
        db_cursor.execute(cmd)

    if not found or args.create_db:
        dhcp_clients = get_dhcp_clients()
        db_cursor.execute(f"CREATE TABLE {getcfg('DB_TABLE')} ({db_fields})")

        count = 0
        for MAC in dhcp_clients:
            count += 1
            db_add_client (MAC, dhcp_clients[MAC])
        db_connection.commit()
        print (f"Database table created with  <{count}>  clients.")
        sys.exit()



    # # Swizzle database table structure or contents - ARCHIVE CODE for later potential use
    # if args.swizzle_db:
    #     # When upgrading, cfg[DB_TABLE] will reference a table in the old format, and a _new table will be created in the new format (and recreated on successive runs).
    #     # This code will deal with the old to new adjustments when building the _new table.
    #     # If not '--commit'ed, cfg[DB_TABLE] is jammed with the _new table name.
    #     # If '--commit'ed, the original table is renamed _bak, and _new is renamed to match as defined in the config file.
    #     # Use model:
    #     #   './routermonitor -l --swizzle-db' while debugging database modifications.  Creates an _new table and displays it.
    #     #   Change the config file to reference the _new table while debugging new code, and run without --swizzle-db.
    #     #   Then finally './routermonitor --swizzle-db --swizzle-commit'.

    #     table_new = getcfg("DB_TABLE") + "_new"
    #     db_cursor.execute("SHOW TABLES")
    #     for row in db_cursor:
    #         if table_new in row['Tables_in_' + getcfg('DB_DB')]:
    #             print(f"Swizzle info:  Found existing new table <{table_new}>.  Deleting.")
    #             db_cursor.execute(f"DROP TABLE {table_new}")
    #             break
    #     db_cursor.execute(f"CREATE TABLE {table_new} ({db_fields})")

    #     # Make adjustments
    #     database_clients = get_database_clients()
    #     epoch1970 = datetime.datetime(1970, 1, 1, tzinfo=datetime.timezone.utc)     # tz aware
    #     for MAC in database_clients:
    #         first_seen = database_clients[MAC]['first_seen'] + " -0700"
    #         first_seenI = int((datetime.datetime.strptime(first_seen, "%a %b %d %H:%M:%S %Y %z") - epoch1970).total_seconds())

    #         expiry = database_clients[MAC]['expiry']
    #         if expiry == "static lease":
    #             expiryI = 0
    #         else:
    #             expiry += " -0700"
    #             expiryI = int((datetime.datetime.strptime(expiry, "%a %b %d %H:%M:%S %Y %z") - epoch1970).total_seconds())

    #         cmd = "INSERT INTO {} (MAC, MACOUI, hostname, notes, first_seen, IP, expiry) VALUES (\'{}\', \'{}\', \'{}\', \'{}\', {}, \'{}\', {})".format(
    #             table_new,
    #             MAC,
    #             database_clients[MAC]['MACOUI'],
    #             database_clients[MAC]['hostname'],
    #             database_clients[MAC]['notes'].replace("'", "''"),
    #             first_seenI,
    #             database_clients[MAC]['IP'],
    #             expiryI )
    #         db_cursor.execute(cmd)
    #     db_connection.commit()

    #     if not args.swizzle_commit:
    #         cfg['DB_TABLE'] = table_new
    #     else:
    #         db_cursor.execute(f"RENAME TABLE {getcfg('DB_TABLE')} to {getcfg('DB_TABLE')+'_bak'}")
    #         db_cursor.execute(f"RENAME TABLE {table_new} to {getcfg('DB_TABLE')}")
    #     db_connection.commit()


    # List known clients from database
    if args.list_db or args.SearchTerm != None:
        get_database_clients(dump=True, search=args.SearchTerm)
        sys.exit()


    # List known clients from dhcp server
    if args.list_dhcp_server:
        get_dhcp_clients(dump=True)
        sys.exit()


    # Print the tail end of the log file
    if args.print_log:
        _fp = getcfg("LogFile")
        if not os.path.isabs(_fp):
            _fp = os.path.join(PROGDIR, _fp)
        subprocess.run(["tail", "-40", _fp]) # getcfg("LogFile")])
        sys.exit()


    # Add a note for a client to the database
    if args.add_note is not None:
        if args.MAC is None:
            print ("ERROR - Must specify the --MAC when using --add-note")
            sys.exit(1)
        db_cursor.execute(f"SELECT * FROM {getcfg('DB_TABLE')} WHERE MAC = '{args.MAC}'")
        if db_cursor.rowcount > 0:
            new_note = args.add_note.replace("'", "''")   # single quotes need to be doubled up in SQL
            db_cursor.execute(f"UPDATE {getcfg('DB_TABLE')} SET notes = '{new_note}' WHERE MAC = '{args.MAC}'")
            db_connection.commit()
        else:
            print (f"MAC address <{args.MAC}> not found in the database.")
            sys.exit(1)
        sys.exit()


    # Delete a client from the database
    if args.delete:
        if args.MAC is None:
            print ("ERROR - Must specify the --MAC when using --delete")
            sys.exit(1)
        db_cursor.execute(f"SELECT * FROM {getcfg('DB_TABLE')} WHERE MAC = '{args.MAC}'")
        if db_cursor.rowcount > 0:
            db_cursor.execute(f"DELETE FROM {getcfg('DB_TABLE')} WHERE MAC = '{args.MAC}'")
            db_connection.commit()
        else:
            print (f"MAC address <{args.MAC}> not found in the database.")
            sys.exit(1)
        sys.exit()


    # Update database from dhcp server
    def do_update():
        try:
            dhcp_clients = get_dhcp_clients()
            database_clients = get_database_clients()
            for MAC in dhcp_clients:
                if MAC not in database_clients:
                    subject = "New LAN client found"
                    msg = f"\n  Hostname:    {dhcp_clients[MAC]['hostname']}\
                            \n  IP address:  {dhcp_clients[MAC]['IP']}\
                            \n  MAC:         {MAC}\
                            \n  MACOUI:      {lookup_MAC(MAC)}"
                    try:
                        snd_notif (subj=subject, msg=msg, log=True)
                    except Exception as e:
                        logging.warning(f"snd_notif error for <{subject}>:  {e}")
                    db_add_client (MAC, dhcp_clients[MAC])
                    continue
                if dhcp_clients[MAC]['hostname'] != database_clients[MAC]['hostname']:
                    msg = (f"{MAC} / {database_clients[MAC]['hostname']:<20} New hostname: {dhcp_clients[MAC]['hostname']}")
                    logging.info(msg)
                    db_cursor.execute(f"UPDATE {getcfg('DB_TABLE')} SET hostname = \'{dhcp_clients[MAC]['hostname']}\' WHERE MAC = '{MAC}'")
                if dhcp_clients[MAC]['IP'] != database_clients[MAC]['IP']:
                    msg = (f"{MAC} / {database_clients[MAC]['hostname']:<20} New IP:       {dhcp_clients[MAC]['IP']}")
                    logging.info(msg)
                    db_cursor.execute(f"UPDATE {getcfg('DB_TABLE')} SET IP = \'{dhcp_clients[MAC]['IP']}\' WHERE MAC = '{MAC}'")
                if dhcp_clients[MAC]['expiry'] != database_clients[MAC]['expiry']:
                    expiry = datetime.datetime.fromtimestamp(dhcp_clients[MAC]['expiry'])
                    msg = (f"{MAC} / {database_clients[MAC]['hostname']:<20} New expiry:   {expiry}")
                    logging.info(msg)
                    db_cursor.execute(f"UPDATE {getcfg('DB_TABLE')} SET expiry = \'{dhcp_clients[MAC]['expiry']}\' WHERE MAC = '{MAC}'")

            db_connection.commit()
        except Exception as e:
            logging.warning(f"Failed in do_update:\n{e}")

    if args.update:
        do_update()
        sys.exit()


    # Service mode
    if args.service:
        while 1:
            loadconfig  (cfgfile= args.config_file, flush_on_reload = True, cfgloglevel=30, cfglogfile_wins=logfile_override)
            do_update()
            time.sleep(getcfg("UpdateInterval"))


    print ("Nothing to do.  Use one of --list-db, --list-dhcp-server, --update, --add-note, --delete, or --create-db.")
    sys.exit(1)


def get_database_clients(dump=False, search=None):
    """ Get clients currently in the database, return a dictionary of dictionaries, keyed by MAC
        {
            MAC:  { hostname:, IP:, expiry:, first_seen:, notes:, MACOUI: }
        }
    """
    db_connection = mysql.connector.connect(database=getcfg("DB_DB"), host=getcfg("DB_HOST"), user=getcfg("DB_USER"), passwd=getcfg("DB_PASS"))
    db_cursor = db_connection.cursor(buffered=True, dictionary=True)
    db_cursor.execute(f"SELECT * FROM {getcfg('DB_TABLE')}")
    clients_list = {}
    for row in db_cursor:
        clients_list[row['MAC']] = {
            "hostname":   row['hostname'],
            "IP":         row['IP'],
            "expiry":     row['expiry'],
            "first_seen": row['first_seen'],
            "notes":      row['notes'],
            "MACOUI":     row['MACOUI'] }

    if dump:
        if args.sort_by == 'MAC':
            clients_list = collections.OrderedDict(sorted(clients_list.items()))
        elif args.sort_by in "first_seen expiry":
            clients_list = collections.OrderedDict(sorted(clients_list.items(), key=lambda t:t[1][args.sort_by]))
        else:
            clients_list = collections.OrderedDict(sorted(clients_list.items(), key=lambda t:t[1][args.sort_by].lower()))
        first=True
        if search == None:
            search = ""
        search = search.lower()
        count = 0
        for MAC in clients_list:

            first_seen = str(datetime.datetime.fromtimestamp(int(clients_list[MAC]['first_seen'])))
            if clients_list[MAC]['expiry'] == 0:
                expiry = "static lease"
            else:
                expiry = str(datetime.datetime.fromtimestamp(int(clients_list[MAC]['expiry'])))

            if search=="" or \
                        search in MAC or \
                        search in clients_list[MAC]['hostname'].lower() or \
                        search in clients_list[MAC]['IP'] or \
                        search in expiry.lower() or \
                        search in first_seen.lower() or \
                        search in clients_list[MAC]['MACOUI'].lower() or \
                        search in clients_list[MAC]['notes'].lower():
                count += 1
                if first:
                    print(f"{'Hostname':<25}  {'First seen':<19}  {'Current IP':<15}  {'IP Expiry':<19}  {'MAC':<17}  "
                        + f"{'MAC Org Unique ID':<{getcfg('MACOUI_field_width', 30)}}  {'Notes'}")                    
                    first = False
                print(f"{clients_list[MAC]['hostname']:<25}  {first_seen:<19}  {clients_list[MAC]['IP']:<15}  {expiry:<19}  {MAC:<17}  "
                    + f"{clients_list[MAC]['MACOUI']:<{getcfg('MACOUI_field_width', 30)}}  {clients_list[MAC]['notes']}")
        print (f"  <{count}>  known clients.")

    return clients_list


def get_dhcp_clients(dump=False):
    """ Get leases from the dhcp server, return a sorted dictionary of dictionaries, keyed by MAC
        {
            MAC:  { hostname:, IP:, expiry: }
        }
    """
    clients_list = {}
    clients = ""
    if not args.dd_wrt:     # pfSense case
        # pf_clients = pf.scrape_pfsense_dhcp(getcfg("PF_DHCP_URL"), getcfg("PF_USER"), getcfg("PF_PASS"))
        pf_clients = scrape_pfsense_dhcp(getcfg("PF_DHCP_URL"), getcfg("PF_USER"), getcfg("PF_PASS"))
        for row in pf_clients:
            if row["End"] == "n/a":
                expiry_timestamp = 0
            else:
                expiry_timestamp = datetime.datetime.strptime(row["End"], getcfg("PF_DATE_FORMAT")).timestamp()    # '2021/11/07 11:51:44'
            clients_list[row["MAC address"]] = {"hostname":row["Hostname"], "IP":row["IP address"], "expiry":expiry_timestamp}
    else:                   # dd-wrt case
        try:
            _cmd = ["ssh", "root@" + getcfg("DDWRT_IP"), "-o", "ConnectTimeout=1", "-T", "cat", getcfg("DDWRT_DHCP")]
            if py_version >= 3.7:
                clients = subprocess.run(_cmd, capture_output=True, text=True).stdout.split("\n")
            else:   #Py 3.6 .run does not support capture_output, so use the old method.
                clients = subprocess.run(_cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True).stdout.split("\n")
        except Exception as e:
            print("Exception <{}>".format(e))
        # 1587457675 00:0d:c5:5c:82:6d 192.168.1.105 Hopper-ETH0 01:00:0d:c5:5c:82:6d
        line_re = re.compile(r"([\d]+) ([\dabcdef:]+) ([\d.]+) ([\S]+)") # [\dabcdef:]+")
        for line in clients:
            xx = line_re.match(line)
            if xx:
                clients_list[xx.group(2)] = {"hostname":xx.group(4), "IP":xx.group(3), "expiry":int(xx.group(1))}
            else:
                if len(line) > 0:
                    print ("ERROR in get_dhcp_clients:  This line looks bogus:\n  ", line)

    if dump:
        if args.sort_by == 'MAC':
            clients_list = collections.OrderedDict(sorted(clients_list.items()))
        elif args.sort_by in "hostname IP":
            clients_list = collections.OrderedDict(sorted(clients_list.items(), key=lambda t:t[1][args.sort_by].lower()))
        elif args.sort_by == "expiry":
            clients_list = collections.OrderedDict(sorted(clients_list.items(), key=lambda t:t[1][args.sort_by]))
        else:
            print ("ERROR in get_dhcp_clients for --list-dhcp-server:  --sort-by must be one of MAC, hostname, IP, or expiry")
            sys.exit(1)

        count = 0
        for client in clients_list:
            count += 1
            if clients_list[client]["expiry"] == 0:
                expiry = "static lease"
            else:
                expiry = str(datetime.datetime.fromtimestamp(int(clients_list[client]["expiry"])))

            print(f"{expiry:<19}  {client}  {clients_list[client]['IP']:<15}  {clients_list[client]['hostname']}")
        print (f"  <{count}>  known clients.")

    return clients_list


def lookup_MAC(MAC):
    r = requests.get("https://oidsearch.s.dd-wrt.com/search/" + MAC[0:8])
    if r.status_code == 200:
        _next = False
        for line in r.text.split("\n"):
            if _next:
                break
            if "<h2>" in line:
                _next = True
        if _next:
            if "<br>" in line:
                search_result = line[0:line.find("<br>")]
            else:
                search_result = line
            if search_result == "":
                search_result = "--none--"
    else:
        search_result = "OID search failed"

    return (search_result)


def scrape_pfsense_dhcp(url, user, password):
    """Queries the pfsense (+v2.4) dhcp leases status page and returns a list of dictionaries, one for each table row.
    The dictionary keys are the column names, such as "Hostname", "IP address", and "MAC address".
    
    Adapted from Github pletch/scrape_pfsense_dhcp_leases.py (https://gist.github.com/pletch/037a4a01c95688fff65752379534455f), thank you pletch.
    """
    s = requests.session()
    r = s.get(url,verify = False)

    matchme = 'csrfMagicToken = "(.*)";var'
    csrf = re.search(matchme,str(r.text))
    payload = {'__csrf_magic' : csrf.group(1), 'login' : 'Login', 'usernamefld' : user, 'passwordfld' : password}
    r = s.post(url,data=payload,verify = False)
    r = s.get(url,verify = False)
    tree = html.fromstring(r.content)

    headers = []
    none_index = 0
    tr_elements = tree.xpath('//tr')
    for header in tr_elements[0]:
        name = header.text
        if name == None:            # Ensure unique name for each column with no name
            name = "None" + str(none_index)
            none_index += 1
        headers.append(name)

    least_list = []
    xpath_base = '//body[1]//div[1]//div[2]//div[2]//table[1]//tbody//tr'
    for row in tree.xpath(xpath_base):
        row_dict = {}
        header_index = 0
        for node in row:
            item_text = node.text
            if item_text != None:
                item_text = item_text.strip()
            row_dict[headers[header_index]] = item_text
            header_index += 1
        least_list.append(row_dict)
    
    return(least_list)



def int_handler(signal, frame):
    logging.warning(f"Signal {signal} received.  Exiting.")
    sys.exit(0)
signal.signal(signal.SIGINT,  int_handler)      # Ctrl-C
signal.signal(signal.SIGTERM, int_handler)      # kill



if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=__doc__ + __version__, formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('SearchTerm', nargs='?',
                        help="Print database records containing this text.")
    parser.add_argument('--update', '-u', action="store_true",
                        help="Check the dhcp server for new connections and update the database.")
    parser.add_argument('--list-db', '-l', action='store_true',
                        help="Print known clients on the network from the database.")
    parser.add_argument('--list-dhcp-server', '-r', action='store_true',
                        help="Print known clients on the network from the dhcp server.")
    parser.add_argument('--sort-by', '-s', choices=['hostname', 'IP', 'first_seen', 'expiry', 'MAC', 'MACOUI', 'notes'], default='MAC',
                        help="Sort --list-db and --list-dhcp-server output (Default 'MAC').")
    parser.add_argument('--print-log', '-p', action='store_true',
                        help="Print the tail end of the log file (last 40 lines).")
    parser.add_argument('--dd-wrt', action='store_true',
                        help="Run in dd-wrt mode (default pfSense mode).")
    parser.add_argument('--create-db', action='store_true',
                        help="Create a fresh database and populate it with the current dhcp server clients.")
    parser.add_argument('--add-note', '-a', type=str,
                        help="Add a note to the db for the specified --MAC.")
    parser.add_argument('--delete', action='store_true',
                        help="Delete from the db the specified --MAC.")
    parser.add_argument('--MAC', '-M', type=str,
                        help="MAC address for --add-note or --delete.")
    parser.add_argument('--config-file', type=str, default=CONFIG_FILE,
                        help=f"Path to the config file (Default <{CONFIG_FILE})>.")
    parser.add_argument('--service', action='store_true',
                        help="Run updates in an endless loop for use as a systemd service.")
    # parser.add_argument('--swizzle-db', action='store_true',
    #                     help="Upgrade db structure/content.")
    # parser.add_argument('--swizzle-commit', action='store_true',
    #                     help="Make db upgrade permanent (else temporary).")
    parser.add_argument('--version', '-V', action='version', version='%(prog)s ' + __version__,
                        help="Return version number and exit.")


    args = parser.parse_args()

    logfile_override = True  if not args.service  else False
    try:
        loadconfig(args.config_file, cfglogfile_wins=logfile_override)
    except Exception as e:
        logging.error(f"Failed loading config file <{args.config_file}> - Aborting.\n  {e}")
        sys.exit(1)

    logging.warning (f"========== {os.path.basename(__file__)} ({__version__}) ==========")
    logging.info (f"Config file <{os.path.abspath(args.config_file)}>")

    # funcs3 min version check
    if not funcs3_min_version_check(FUNCS3_MIN_VERSION):
        logging.error(f"funcs3 module must be at least version <V{FUNCS3_MIN_VERSION}>.  Found <{funcs3_version}>.  Aborting.")
        sys.exit(1)
    else:
        logging.debug(f"funcs3 module version <{funcs3_version}> (min required <V{FUNCS3_MIN_VERSION}>)")


    if not args.update and not args.list_dhcp_server and not args.print_log and not args.create_db and not args.add_note and not args.delete and not args.service:
        args.list_db = True

    main()
    sys.exit()
